#!/bin/bash
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=bash
# -*- mode: sh; indent-tabs-mode: nil; sh-basic-offset: 4 -*-
exec 2>&1
test -e /etc/profile && . /etc/profile


# Depending on how client-server-script is started, "/usr/local/bin" is not
# always in the $PATH
PATH="/usr/local/bin:$PATH"

max_rb_attempts=1
rb_exit_timeout=3
rb_exit_abort=4
rb_exit_nonet=5
default_timeout=240
client_server_script_timeout=720
runtime_padding=120

function exit_error() {
    local message=$1; shift
    local code=$1; shift
    echo -e "[ERROR]$message\n"
    echo "Exiting"
    if [ -z "$code" ]; then
        exit 1
    else
        exit $code
    fi
}

function do_roadblock() {
    local label=$1; shift
    local leader=$1; shift
    local timeout=$1; shift
    local extra=$1; shift
    if [ -z "$label" ]; then
        exit_error "[ERROR]do_roadblock() label not provided"
    fi
    if [ -z "$timeout" ]; then
        exit_error "[ERROR]do_roadblock() timeout not provided"
    fi
    local msgs_file="$roadblock_msgs_dir/$label.json"
    local cmd=""
    local role="follower"
    cmd="$cmd $roadblock_bin --role=follower --redis-server=$roadblock_server"
    cmd="$cmd --leader-id=$leader --timeout=$timeout --redis-password=$roadblock_passwd"
    cmd="$cmd --follower-id=$cs_label --message-log=$msgs_file $extra"
    local uuid="$roadblock_id:$label"
    printf "\n\n"
    echo "Starting roadblock [`date`]"
    echo "role: $role"
    echo "uuid (without attempt ID embedded): $uuid"
    echo "timeout: $timeout"

    local attempts=0
    local rc=99
    if [ "$use_roadblock" == "1" ]; then
        while [ $attempts -lt $max_rb_attempts -a $rc -ne 0 -a $rc -ne $rb_exit_abort ]; do
            let attempts=$attempts+1
            echo "attempt number: $attempts"
            echo "uuid: $attempts:$uuid"
            #echo "going to run this roadblock command: $cmd"
            local output=`$cmd --uuid=$attempts:$uuid 2>&1`
            rc=$?
            echo "roadblock output BEGIN"
            printf "%s" "$output"
            echo "roadblock output END"
            echo "roadblock exit code: $rc"
            if echo $output | grep -q -P -- '(Name\sor\sservice\snot\sknown)'; then
                rc=$rb_exit_nonet
            elif echo $output | grep -q -P -- '(Exiting\swith\sabort|Roadblock\sCompleted\swith\san\sAbort)'; then
                rc=$rb_exit_abort
            elif echo $output | grep -q -P -- '(The\sroadblock\shas\stimed\sout|ERROR:\sRoadblock\sfailed\swith\stimeout)'; then
                rc=$rb_exit_timeout
            fi
            if [ -f roadblock-messages ]; then
                echo "messages from roadblock:"
                cat roadblock-messages
            fi
        done

        echo "total attempts: $attempts"
        echo "Completed roadblock [`date`]"
        printf "\n\n"

    else
        return 0
    fi

    if [ $rc -eq 0 -o $rc -eq $rb_exit_abort ]; then
        return $rc
    else
        exit_error "$rb_exit_msg"
    fi
}

function scp_from_controller() {
    local ssh_id_file=$1; shift
    local src=$1; shift
    local dest=$1; shift
    if [ -z "$ssh_id_file" ]; then
        exit_error "scp_from_controller(): ssh_id_file not defined"
    fi
    if [ -z "$src" ]; then
        exit_error "scp_from_controller(): src not defined"
    fi
    if [ -z "$dest" ]; then
        exit_error "scp_from_controller(): dest not defined"
    fi
    local scp_attempts=1
    local scp_rc=1
    local max_attempts=10
    scp_cmd="scp -o StrictHostKeyChecking=no"
    scp_cmd+=" -o BatchMode=yes"
    scp_cmd+=" -v"
    scp_cmd+=" -o ConnectionAttempts=10"
    scp_cmd+=" -i $ssh_id_file"
    scp_cmd+=" -r $rickshaw_host:$src $dest"
    while [ $scp_rc -gt 0 -a $scp_attempts -lt $max_attempts ]; do
        echo "Trying to scp $rickshaw_host:$src $dest"
        scp_output=`$scp_cmd 2>&1`
        scp_rc=$?
        if [ $scp_rc -gt 0 ]; then
            echo "scp failed, trying again"
            echo "scp exit code: $scp_rc"
            echo "scp command: $scp_cmd"
            echo "scp output:"
            echo "$scp_output"
            sleep $scp_attempts
        fi
        let scp_attempts=$scp_attempts+1
    done
    if [ $scp_attempts -ge $max_attempts ]; then
        exit_error "Could not copy $src from $rickshaw_host"
    fi
}

function archive_to_controller() {
    local ssh_id_file=$1; shift
    local src=$1; shift # a directory to archive from
    local dest=$1; shift # a destination directory to write archive
    local ssh_attempts=1
    local ssh_rc=1
    local max_attempts=10
    if [ -z "$ssh_id_file" ]; then
        exit_error "archive_to_controller(): ssh_id_file not defined"
    fi
    if [ -z "$src" ]; then
        exit_error "archive_to_controller(): src_file not defined"
    fi
    if [ -z "$dest" ]; then
        exit_error "archive_to_controller(): destination is not defined"
    fi
    pushd $src || exit_error "Could not chdir to $src"
    while [ $ssh_rc -gt 0 -a $ssh_attempts -lt $max_attempts ]; do
        echo "Trying to tar/ssh fron $src to $rickshaw_host:$dest"
        tar czf - . | ssh \
                       -o StrictHostKeyChecking=no \
                       -o ConnectionAttempts=10 \
                       -i "/tmp/rickshaw_id.rsa" \
                       $rickshaw_host "dd of=$dest"
        ssh_rc=$?
        echo "ssh exit code: $ssh_rc"
        if [ $ssh_rc -gt 0 ]; then
            echo "tar/ssh failed, trying again"
            sleep $ssh_attempts
        fi
        let ssh_attempts=$ssh_attempts+1
    done
    popd >/dev/null
    if [ $ssh_attempts -ge $max_attempts ]; then
        exit_error "Could not archive $src to $rickshaw_host:$dest"
    fi
}

echo "client-server-script env:"
env
echo "client-server-script params:"
echo "$@"
echo
echo os-release:
cat /etc/os-release
echo
echo "uname:"
uname -a
echo
version=20200509
echo "version: $version"
echo
longopts="rickshaw-host:,base-run-dir:,endpoint-run-dir:,cs-label:,roadblock-server:"
longopts="${longopts},roadblock-passwd:,roadblock-id:"
opts=$(getopt -q -o "" --longoptions "$longopts" -n "getopt.sh" -- "$@");
if [ $? -ne 0 ]; then
    exit_error "\nUnrecognized option specified: $@\n\n"
fi
eval set -- "$opts";
while true; do
    case "$1" in
        --rickshaw-host)
            shift;
            rickshaw_host="$1"
            shift;
            ;;
        --base-run-dir)
            shift;
            base_run_dir=$1
            shift;
            ;;
        --cs-label)
            shift;
            cs_label="$1"
            shift;
            ;;
        --endpoint-run-dir)
            shift;
            endpoint_run_dir="$1"
            shift;
            ;;
        --roadblock-server)
            shift;
            roadblock_server="$1"
            shift;
            ;;
        --roadblock-passwd)
            shift;
            roadblock_passwd="$1"
            shift;
            ;;
        --roadblock-id)
            shift;
            roadblock_id="$1"
            shift;
            ;;
        --)
            shift;
            break;
           ;;
        *)
           exit_error "Unexpected argument [$1]"
           shift;
           break;
           ;;
    esac
done

if [ -z "$endpoint_run_dir" ]; then
    exit_error "The endpoint run directory (--endpoint-run-dir) was not defined"
fi
if [ -z "$cs_label" ]; then
    exit_error "The client/server label (--cs-label) was not defined"
fi
if echo $cs_label | grep -q -P '^(\w+)-\d+$'; then
    echo "client_label \"$cs_label\" is valid"
else
    exit_error 'cs_label "'$cs_label'" does not adhere to regex /^(\w+)-\d+$/'
fi
export RS_CS_LABEL=$cs_label

# Directories on the client/server
cs_dir="`mktemp -d`"
echo "cs_dir: $cs_dir"
tool_start_cmds="$cs_dir/tool-start"
tool_stop_cmds="$cs_dir/tool-stop"
roadblock_msgs_dir="$cs_dir/roadblock-msgs"
mkdir -p "$roadblock_msgs_dir"
cs_type=`echo $cs_label | awk -F- '{print $1}'`
cs_id=`echo $cs_label | awk -F- '{print $2}'`

# Directories on the controller
config_dir="$base_run_dir/config"
client_server_config_dir="$config_dir/client-server"
tool_cmds_dir="$config_dir/tool-cmds/$cs_type"
tool_cmds_dir="$config_dir/tool-cmds/$cs_type"
run_dir="$base_run_dir/run"
archives_dir="$run_dir/client-server/archives"

if [ -z "$rickshaw_host" ]; then
    exit_error "Exiting due to rickshaw host not being set"
fi

roadblock_bin="/usr/local/bin/roadblock.py"
use_roadblock=1
if [ -z "$roadblock_server" ]; then
    echo "Cannot use roadblock for synchronizaton because a server was not provided"
    use_roadblock=0
fi
if [ -z "$roadblock_id" ]; then
    echo "Cannot use roadblock for synchronizaton because an ID was not provided"
    use_roadblock=0
fi
if [ -z "$roadblock_passwd" ]; then
    echo "Cannot use roadblock for synchronizaton because a password was not provided"
    use_roadblock=0
fi

if [ "$use_roadblock" == "1" ]; then
    if [ ! -e $roadblock_bin ]; then
        exit_error "Could not find roadblock binary: $roadblock_bin"
    fi
fi

pushd "$cs_dir" >/dev/null || exit_error "Could not chdir to $cs_dir"

if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    label=client-server-script-start
    do_roadblock $label "controller" $client_server_script_timeout
else
    label=collector-script-start
    do_roadblock $label "endpoint" $client_server_script_timeout
fi

ssh_id_file="/tmp/rickshaw_id.rsa"
if [ ! -z "$ssh_id" ]; then
   echo -e "$ssh_id" > $ssh_id_file
   chmod 600 $ssh_id_file
fi
if [ ! -e $ssh_id_file ]; then
    exit_error "ssh key $ssh_id_file was not found"
fi

# Get files required to run benchmark and tools
cs_files_list="$cs_type-files-list"
# First get the file that tells us what other files to get
scp_from_controller "$ssh_id_file" "$client_server_config_dir/$cs_files_list" "$cs_files_list"
if [ ! -e "$cs_files_list" ]; then
    exit_error "Could not find $cs_files_list"
fi
dest_file=""
src_file=""
# Now we know what files to get
while read line; do
    # $cs_files_list has line like:
    # src=<file>
    # dest=<file>
    # (then repeat)
    if [ -z "$src_file" ]; then
        src_file=`echo $line | grep "^src=" | awk -F= '{print $2}'`
        if [ -z "$src_file" ]; then
            exit_error "source file not found in $cs_type-file-list"
        fi
    else 
        dest_file=`echo $line | grep "^dest=" | awk -F= '{print $2}'`
        if [ -z "$dest_file" ]; then
            exit_error "dest file not found in $cs_type-file-list"
        fi
        scp_from_controller "$ssh_id_file" "$src_file" "$dest_file"
        dest_file=""
        src_file=""
    fi
done < "$cs_files_list"

# Get the benchmark and tool commands
if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    cs_start_bench_cmds="$cs_label-start-bench.cmds"
    scp_from_controller "$ssh_id_file" "$client_server_config_dir/bench-cmds/$cs_type/$cs_id/start" "bench-start-cmds"
    if [ ! -e "bench-start-cmds" ]; then
        exit_error "bench cmds file bench-start-cmds not found. PWD: `/bin/pwd`  LS: `/bin/ls`"
    fi
    if [ "$cs_type" == "client" -a "$cs_id" == "1" ]; then
        scp_from_controller "$ssh_id_file" "$client_server_config_dir/bench-cmds/$cs_type/$cs_id/runtime" "bench-runtime-cmds"
    fi
    if [ "$cs_type" == "server" ]; then
        scp_from_controller "$ssh_id_file" "$client_server_config_dir/bench-cmds/$cs_type/$cs_id/stop" "bench-stop-cmds"
        if [ ! -e "bench-stop-cmds" ]; then
            exit_error "bench cmds file bench-stop-cmds not found. PWD: `/bin/pwd`  LS: `/bin/ls`"
        fi
    fi
    scp_from_controller "$ssh_id_file" "$tool_cmds_dir/$cs_id/start" "$tool_start_cmds"
    scp_from_controller "$ssh_id_file" "$tool_cmds_dir/$cs_id/stop" "$tool_stop_cmds"
else
    # non-client/server get tool cmds based on endpoint-specific collector = $cs_label like "worker"
    scp_from_controller "$ssh_id_file" "$tool_cmds_dir/start" "$tool_start_cmds"
    scp_from_controller "$ssh_id_file" "$tool_cmds_dir/stop" "$tool_stop_cmds"
fi

if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    # Regular clients/servers sync with the controller before starting tools
    label=client-server-start-tools
    do_roadblock $label "controller" $default_timeout
else
    # Non client/servers, "collectors", sync with the endpoint that created them
    # because the controller does not know how many collectors there are, but
    # the endpoint does.
    label=collector-start-tools
    do_roadblock $label "endpoint" $default_timeout
fi

for this_tool_cmds in "$tool_start_cmds" "$tool_stop_cmds"; do
    if [ ! -e $this_tool_cmds ]; then
        exit_error "Tool cmd file $this_tool_cmd was not found"
    fi
done
mkdir -p tool-data
pushd tool-data >/dev/null
while read line; do
    tool_name=`echo $line | awk -F: '{print $1}'`
    tool_cmd=`echo $line | sed -e s/^$tool_name://`
    /bin/mkdir -p $tool_name
    pushd $tool_name >/dev/null
    $tool_cmd
    popd >/dev/null
done <"$tool_start_cmds"
popd >/dev/null

declare -A bench_runtime_cmds
declare -A bench_start_cmds
declare -A bench_stop_cmds
if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    count=0
    if [ -e bench-start-cmds ]; then
        while read line; do
            bench_start_cmds[$count]="$line"
            let count=$count+1
        done < bench-start-cmds
    else
        exit_error "bench-start-cmds not found"
    fi
    count=0
    if [ -e bench-runtime-cmds -a "$cs_id" == 1 ]; then
        while read line; do
            bench_runtime_cmds[$count]="$line"
            let count=$count+1
        done < bench-runtime-cmds
    fi
fi
if [ "$cs_type" == "server" ]; then
    if [ -e bench-stop-cmds ]; then
        count=0
        while read line; do
            bench_stop_cmds[$count]="$line"
            let count=$count+1
        done < bench-stop-cmds
    else
        exit_error "bench-stop-cmds not found"
    fi
fi
    
abort_opt=""
# Run the actual tests by processing the commands array
if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    timeout=$default_timeout
    len=${#bench_start_cmds[@]}
    for (( i=0; i<$len; i++ )); do
        iter_samp=`echo ${bench_start_cmds[$i]} | awk '{print $1}'`
        start_cmd=`echo ${bench_start_cmds[$i]} | sed -e s/^$iter_samp//`
        runtime_cmd=`echo ${bench_runtime_cmds[$i]} | sed -e s/^$iter_samp//`
        if [ "$cs_type" == "server" ]; then
            stop_cmd=`echo ${bench_stop_cmds[$i]} | sed -e s/^$iter_samp//`
        fi
        iter=`echo $iter_samp | awk -F- '{print $1}'`
        samp=`echo $iter_samp | awk -F- '{print $2}'`
        iter_samp_dir="$cs_dir/iteration-$iter/sample-$samp"
        cs_msgs_dir="$iter_samp_dir/msgs"
        cs_tx_msgs_dir="$cs_msgs_dir/tx" # Messages a client or server wants to transmit
        cs_rx_msgs_dir="$cs_msgs_dir/rx" # Messages a client or server has received
        for this_dir in "$iter_samp_dir" "$cs_msgs_dir" "$cs_tx_msgs_dir" "$cs_rx_msgs_dir"; do
            echo "mkdir -p $this_dir"
            mkdir -p "$this_dir" || exit_error "Could not mkdir $this_dir"
        done
        # The following should be replaced by creating hardlinks in each sample
        # dir for each file in $cs_file_list
        find . -mindepth 1 -maxdepth 1 -type f | grep -v -- "$cs_label-stderrout.txt" | \
            grep -v -- "$cs_label-bench.cmds" | grep -v -- "$cs_label-tool.cmds" | \
            grep -v -- "$cs_files_list" | \
            cpio -pdum iteration-$iter/sample-$samp/ ||
            exit_error "Could not copy files from $cs_dir to $iter_samp_dir with find & cpio"
        pushd $iter_samp_dir || exit_error "Could not chdir to $iter_samp_dir"
        echo PWD: `/bin/pwd`
        for sync in server-start client-start client-stop server-stop; do
            label="test-${iter}-${samp}:$sync"
            msgs_file="$roadblock_msgs_dir/$label.json"
            this_timeout=$default_timeout
            if [ ! -z "$runtime_cmd" -a "$sync" == "client-start" -a "$cs_id" == "1" -a "$abort_opt" == "" ]; then
                user_message_opt=""
                # Get estimated runtime if possible and send to everyone else
                echo "going to run this command to get the runtime: $runtime_cmd"
                runtime=`$runtime_cmd`
                if [ $? -eq 0  -a ! -z "$runtime" ]; then
                    # Add padding to benchmark runtime to give
                    # enough time for everyone to call roadblock
                    let this_timeout=$runtime+$runtime_padding
                    user_json_file="`mktemp`"
                    echo "adding timeout message to $cs_tx_msgs_dir"
                    echo '{"recipient":{"type":"all","id":"all"},"user-object":{"timeout":"'$this_timeout'"}}' >"$cs_tx_msgs_dir/timeout"
                fi
            fi
            pending_tx_msgs="`/bin/ls -1 $cs_tx_msgs_dir`"
            if [ ! -z "$pending_tx_msgs" -a "$abort_opt" == "" ]; then
                echo "Found messages in $cs_tx_msgs_dir, preparing them to send"
                mkdir -p ${cs_tx_msgs_dir}-sent
                msgs_json_file="$iter_samp_dir/rb-msgs-$sync"
                echo "[" >"$msgs_json_file"
                for msg in $pending_tx_msgs; do
                    # TODO validate JSON schema
                    echo "Adding $msg to $msgs_json_file"
                    cat "$cs_tx_msgs_dir/$msg" >>"$msgs_json_file"
                    /bin/mv "$cs_tx_msgs_dir/$msg" "${cs_tx_msgs_dir}-sent"
                    echo "," >>"$msgs_json_file"
                done
                echo '{"recipient":{"type":"all","id":"all"},"user-object":{"sync":"'$sync'"}}]' >>$msgs_json_file
                echo "full message to send:"
                cat "$msgs_json_file"
                # TODO changing this to $extra_opt everywhere
                abort_opt=" --user-messages=$msgs_json_file"
            fi
            do_roadblock "$label" "controller" $timeout "$abort_opt"
            rb_rc=$?
            cmd_rc=0
            echo roadblock $label exit code: $rb_rc
            if [ $rb_rc -eq $rb_exit_abort ]; then
                echo -e "\nReceived abort exit code from iteration $iter, sample $samp roadblock"
                echo -e "\nWill not run remaining tests\n"
                if [ "$cs_type" == "server" ]; then
                    # Since this is bailing out early, this is our only chance to stop the server
                    echo -e "\nAttempting to stop server\n"
                    $stop_cmd
                fi
                break 2 # break out of the outer loop
            fi
            if [ $rb_rc -eq 2 ]; then
                exit_error "roadblock for client-server-start-test:$iter-$samp timed out"
            fi
            timeout=$default_timeout
            if [ -f $msgs_file ]; then
                count=1
                if [ $cs_type == "client" ]; then
                    cs_buddy="server-$cs_id"
                else
                    cs_buddy="client-$cs_id"
                fi
                echo "Found messages file: $msgs_file"
                jq -cr '.received[] | select(.payload.sender.id == "'$cs_buddy'" and 
                        .payload.message.command == "user-object") | .payload.message' $msgs_file\
                | while read line; do
                    msg="$sync:$count"
                    echo "Found user-object message from $cs_buddy: $line"
                    echo "$line" | jq '."user-object"' >"$cs_rx_msgs_dir/$msg"
                    let count=$count+1
                done
                # TODO: process the newly created msg files above instead of scanning the entire messages array again
                next_timeout=`jq -r '.received[] | .payload.message."user-object".timeout ' $msgs_file | grep -v null`
                jq -r '.received[] | .payload.message."user-object".timeout ' $msgs_file
                if [ ! -z "$next_timeout" ]; then
                    echo "Applying timeout value of $next_timeout to next roadblock sync"
                    timeout=$next_timeout
                fi
            fi
            # These combinations don't run a command:
            #  sync=server-start & cs_type=client
            #  sync=client-start & cs_type=server
            #  sync=server-stop & cs_type=client
            if [ "$sync" == "server-start" -a "$cs_type" == "server" ]; then
                echo "Running $sync command: $start_cmd"
                $start_cmd
                cmd_rc=$?
            elif [ "$sync" == "client-start" -a "$cs_type" == "client" ]; then
                echo "Running $sync command: $start_cmd"
                $start_cmd
                cmd_rc=$?
            elif [ "$sync" == "server-stop" -a "$cs_type" == "server" ]; then
                echo "Running $sync command: $stop_cmd"
                $stop_cmd
                cmd_rc=$?
            fi
            if [ $cmd_rc -gt 0 ]; then
                # An abort message must be sent so the other members know how to procede
                abort_opt=" --abort"
                echo -e "\nNon-zero exit code from iteration $iter, sample $samp"
                echo -e "\nWill send abort message on next roadblock\n"
                echo -e "\nWill not run remaining tests\n"
                # Since the rest of the roadblocks for this test will not be done, stop the server now
                if [ "$cs_type" == "server" ]; then
                    echo -e "\nAttempting to stop server\n"
                    $stop_cmd
                fi
            fi
        done
        popd >/dev/null  # from $iter_sampl_dir back to $cs_dir
    done
fi

if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    label=client-server-stop-tools
    do_roadblock $label "controller" $default_timeout
    echo -e "\nClients/servers stopping tools"
else
    # Sync with your *endpoint* for collector tools because the contoller
    # does not determine and does not know what tool collectors there may be
    label=collector-stop-tools
    do_roadblock $label "endpoint" 86400
    echo -e "\nCollectors stopping tools"
fi
pushd tool-data >/dev/null
while read line; do
    tool_name=`echo $line | awk -F: '{print $1}'`
    tool_cmd=`echo $line | sed -e s/^$tool_name://`
    pushd $tool_name >/dev/null
    $tool_cmd
    popd >/dev/null
done <"$tool_stop_cmds"
popd >/dev/null

if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    label=client-server-send-data
    do_roadblock $label "controller" $default_timeout
    echo -e "\nClients/servers copying data back to controller"
else
    # Same as collector-stop-tools, sync with endpoint
    label=collector-send-data
    do_roadblock $label "endpoint" $default_timeout
    echo -e "\nCollectors copying data back to controller"
fi

# Send all of the test data to the controller and remove local data
archive_to_controller "$ssh_id_file" "$cs_dir" "$archives_dir/$cs_label-data.tgz"

popd >/dev/null
if [ "$cs_type" == "client" -o "$cs_type" == "server" ]; then
    label=client-server-script-finish
    do_roadblock $label "controller" $default_timeout
    echo -e "\nAll client/server scripts are finished"
else
    # Same as collector-stop-tools, sync with endpoint
    label=collector-script-finish
    do_roadblock $label "endpoint" $default_timeout
    echo -e "\nAll collector scripts are finished"
fi
/bin/rm -rf $cs_dir
